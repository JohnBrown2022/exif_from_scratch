# V1 模版系统重构构想：从“手写模板”到“声明式元素 + 网格布局 + 双图层渲染”

> 目标：把当前的 Canvas 水印模板，从「每个模板一段自定义绘制代码」升级为「由若干可编辑元素组成的模板定义」，并引入**双图层绘制**与**网格定位**，让新增/调整模板变成“改配置”，而不是“改代码”。

## 0. 已确认的方向（根据你的回答固化为约束）
- 模板落地形式：**JSON 文件**（后续可导入/导出/分享）
- 布局系统：**12 列栅格**（建议默认 rows=12，用于将来位置编辑）
- 编辑器优先级：先做 **Level 1（开关/内容/Logo）**
- 厂商 Logo：需要 **两套风格（彩色/单色）**
  - Level 1 不支持“手动指定厂商 key”（仅 `auto/off`）
  - 单色模式颜色支持用户自选（默认可给一个合理初始值）
- 变体：**暂不做** 横图/竖图不同排版（variants 先搁置）
  - Level 1 文本覆盖：仅允许覆盖 `slogan/固定文案`（不开放 camera/lens/settings/date 覆盖）

## 1. 现状复盘（基于当前实现）

### 1.1 当前渲染管线
- 预览：`src/app/panels/PreviewPanel.tsx` → `renderWatermark(...)`
- 导出：`src/core/export/exportWatermarked.ts` → `renderWatermark(...)` → `canvas.toBlob(...)`
- 渲染核心：`src/core/render/renderer.ts`
  - `template.getLayout(...)` 计算 **canvas尺寸** + `imageRect`
  - 画背景（可选 `background` + `template.renderBackdrop`）
  - 在 `imageRect` 内绘制图片（contain/cover + 圆角裁剪 + 旋转）
  - 如模板需要，基于 `imageRect` 抽色板：`extractPaletteFromCanvasArea(...)`
  - `template.render(...)` 画文字/分割线/色卡等
- 模板集合：`src/core/render/templates.ts`（现在仍是“每个模板一段 imperative 绘制逻辑”）

### 1.2 当前 EXIF / 文案拼装
- EXIF 读取：`src/core/exif/readExif.ts`
- 常用格式化：`src/core/exif/format.ts`
  - `formatCameraName / formatLensName / formatSettingsLine / formatDateTime`
  - `buildWatermarkFields(exif)` 输出 `{camera,lens,settings,date}`

### 1.3 厂商 Logo（当前实现）
- 解析 make/model → 归一到 key：`src/core/brand/makerLogo.ts#inferMakerLogoKey`
- 加载 Logo：`src/core/brand/makerLogo.ts#loadMakerLogo`
  - 目前支持“内置素材（src/assets/maker/*.svg）优先 + localStorage 覆盖（如果存在）”
- 使用位置：模板绘制时通过 `TemplateRenderInput.makerLogo` 拿到并绘制（例如 `EZMark 卡片`、`Picseal 横幅`、`经典白底栏`）

### 1.4 当前问题（为什么需要更高层抽象）
1. **模板不可组合**：每个模板都是一段绘制代码，复用/变体难（例如“底栏三段信息”换成“底栏两段信息”仍要写新模板）。
2. **元素不可编辑**：用户无法单独开关/修改“相机名/镜头/参数/日期/Logo”等元素，只能换模板。
3. **布局不可声明**：没有统一的布局系统（网格、对齐、约束），全靠手算像素和 `fitText(...)`。
4. **双图层概念未显式化**：现在虽然有 `imageRect`（图片区）与额外 canvas 区域，但“图层/区域/元素”没有统一模型。

### 1.5 现有模板的“元素拆解”示例（为新抽象做对照）
> 下面是把现有模板按“区域 + 元素”拆开，证明它们确实可以被数据化表达。

#### `classic_footer`（经典白底栏）
- Zones：
  - `photo`：原图区域（contain）
  - `footer`：白底信息栏（在 canvas 下方扩展）
- Elements：
  - `rect`：footer 背景 + 顶部分隔线
  - `text(camera)`：左侧标题
  - `text(lens)`：左侧副标题（条件显示）
  - `text(settings)`：右侧参数行
  - `logo(maker)`：居中品牌（无 logo 时回退 make 文本）

#### `ezmark_card`（EZMark 卡片）
- Zones：
  - `photo`：原图区域（contain，圆角裁剪）
  - `footer`：白底信息条 + 色卡（在 canvas 下方扩展）
  - `canvas`：包含外边距（卡片阴影）
- Elements：
  - `rect(card)`：卡片圆角 + 投影（backdrop）
  - `divider`：图片与 footer 的分割线
  - `stack(left)`：相机名 + 日期（左侧纵向堆叠）
  - `logo(maker)`：右上品牌标识（需要与参数行避让）
  - `text(settings)`：右侧参数行
  - `swatches(palette)`：右下色卡（依赖 palette）

#### `picseal_banner`（Picseal 横幅）
- Zones：
  - `photo`：原图区域（contain）
  - `footer`：横幅信息区（在 canvas 下方扩展）
- Elements：
  - `rect`：footer 背景 + 顶部分隔线
  - `divider`：横幅中间竖分隔线
  - `stack(left)`：相机名 + 日期
  - `stack(right)`：镜头名 + 参数行
  - `logo(maker)`：右侧品牌标记（或 make 文本回退）

---

## 2. 目标抽象（你提出的思路落到可实现的模型）

### 2.1 双图层绘制（核心语义）
把一次导出视为两个概念层：
- **Photo Layer（照片层）**：只负责把照片按规则放进 `photoRect`（contain/cover、圆角、旋转等）。
- **Overlay Layer（信息层）**：负责画所有“EXIF 信息/Logo/分隔线/色卡”等元素。

并引入一个关键规则：
- 若模板存在“额外区域”（边框/底部信息框/留白），则 Overlay 元素默认画在**额外区域**（不污染照片内容）→ 视觉上就是你说的“**双图层**”。
- 若模板没有额外区域（`canvasRect == photoRect`），则 Overlay 元素直接画在**照片区域之上** → “**单图层**”。

> 实现上不一定要真的两张 canvas；可以是同一张 canvas 的分阶段绘制，但**模板定义与元素定位**必须能表达“画在照片内/画在照片外”。

### 2.2 元素（Element）抽象
把水印中可见的“东西”拆成一组**元素**（可渲染、可开关、可编辑、可定位）：

**典型元素清单（对照现有模板）**
- `makerLogo`：厂商 Logo（或 fallback 文本）
- `camera`：相机名（Make + Model）
- `lens`：镜头名
- `settings`：参数行（焦距 / 光圈 / 快门 / ISO）
- `date`：拍摄时间
- `divider`：分割线
- `swatches`：色卡（来自抽色板）
- `badge/slogan`：比如 `SHOT ON ...`、`EXIF` 这类固定/半固定文案
- `background`：底栏底色、卡片阴影、边框等视觉结构

每个元素至少需要这些信息：
- **数据绑定（Binding）**：内容来自 EXIF/模板常量/计算结果（例如 `settingsLine(exif)`）
- **可编辑性（Editable）**：允许用户覆盖内容/开关显示/换 logo key
- **定位（Placement）**：基于“区域 + 网格 + 对齐”得到一个渲染矩形
- **样式（Style）**：字体、字号、字重、颜色、透明度、阴影、圆角等
- **条件（Condition）**：如 EXIF 缺失、空间不足、横竖图变体等

> 这一步的关键不是“把模板写得更花”，而是把“元素”变成一等公民：模板 = 元素清单 + 条件 + 布局信息。

### 2.3 区域（Zone）+ 网格（Grid）定位
为了实现你说的“基于网格的位置定位”，建议把布局拆成两层：

1) **区域 Zone**：先把画布切成可命名的矩形区域（rect）
- `canvas`：整张输出画布
- `photo`：照片区域（现有 `imageRect` 的升级版）
- `footer` / `header` / `frame`：额外区域（有些模板才存在）

2) **网格 Grid**：每个 Zone 可选绑定一个网格系统，用网格坐标定位元素
- 例：`footer` 使用 `cols=12, rows=1`，左 5 列放相机信息，中间 2 列放 Logo，右 5 列放参数/日期
- 例：`photo` 使用 `cols=12, rows=12`，角标类元素放到右下 `col=8..12,row=10..12`

这样模板里保存的就可以是：
- “哪个元素在哪个 zone”
- “占用哪几列/哪几行”
- “在格子内怎么对齐（left/center/right, top/middle/bottom）”
- “最大宽度/截断规则（fitText）”

### 2.4 双图层在模型中的表达方式
在模型层不需要显式写“单图层/双图层”开关，而是由 **Zone 是否存在额外区域**自然决定：
- 若 `canvas == photo`（没有额外区域），Overlay 元素的默认 zone 就是 `photo`（信息叠在照片上）。
- 若 `canvas != photo`（存在 footer/frame），Overlay 元素默认 zone 就是 `footer/frame`（信息落在照片外）。

这可以变成模板的一个默认规则：
- `defaultOverlayZone: 'photo' | 'footer' | ...`

---

## 3. 建议的“声明式模板”数据结构（可落地）

> 重点：模板尽量“数据化”，但允许少量可控的“计算”（例如随画布大小缩放的 padding/字号）。

### 3.1 核心类型（概念草图）

#### TemplateDefinition
- `id/name/description`
- `layout`：定义 `canvasRect/photoRect/zones`
- `scaleModel`：用“设计稿宽度 + clamp”生成统一缩放系数（替代在 JSON 里写公式）
- `tokens`：**只放常量**（以 design px 表示），运行时统一乘以 scale
- `requirements`：是否需要 palette、是否需要 makerLogo 等
- `layers`：Photo layer + Overlay layer（以及可选 Backdrop layer）
- `elements[]`：声明式元素列表

#### ElementSpec
- `id`
- `type`: `text | logo | rect | divider | swatches | group(stack) | ...`
- `zone`: `photo | footer | canvas | ...`
- `grid` 或 `anchor`（两者其一）
- `style`
- `bind`（对 text/logo 等）
- `condition`（可选）
- `editable`（可选）

### 3.1.1 为什么需要 `scaleModel`
你现在看到的模板（`templates.ts`）里有大量类似：
- `scale = clamp(width / 900, 0.75, 1.15)`
- `padding = clamp(16 * scale, 12, 22)`

如果模板改成 JSON，又不想引入一个复杂表达式语言，那么最实用的做法是：
- 每个模板声明一个 `designWidth`（例如 900/1000/1200）
- 引擎统一算出 `scale = clamp(outputWidth / designWidth, min, max)`
- 模板里所有 size 都用 “design px” 存，渲染时乘 `scale` 再 clamp（必要时）

这样 JSON 里仍然是“数据”，引擎里保留少量可控计算，写模板的人也能直觉调整。

### 3.1.2 一个可行的 JSON 示例（`classic_footer`）
> 这不是最终格式，只是为了说明“zones + grid + elements”的表达能力。

```jsonc
{
  "id": "classic_footer",
  "name": "经典白底栏",
  "description": "图 + 白色底栏（左右信息 + 中间品牌标记）。",
  "scaleModel": { "designWidth": 1200, "min": 0.75, "max": 1.1 },
  "layout": {
    "kind": "photo_plus_footer",
    "footerHeight": { "designPx": 60, "minPx": 52, "maxPx": 86 },
    "photoDrawMode": "contain"
  },
  "zones": {
    "footer": {
      "grid": { "cols": 12, "rows": 12, "padding": { "designPx": 12 } }
    },
    "photo": {
      "grid": { "cols": 12, "rows": 12, "padding": { "designPx": 0 } }
    }
  },
  "requirements": { "makerLogo": true },
  "elements": [
    { "id": "footer_bg", "type": "rect", "zone": "footer", "style": { "fill": "rgba(255,255,255,0.98)" } },
    { "id": "footer_topline", "type": "divider", "zone": "footer", "style": { "color": "rgba(0,0,0,0.06)" } },

    {
      "id": "camera",
      "type": "text",
      "zone": "footer",
      "grid": { "col": 1, "colSpan": 5, "row": 1, "rowSpan": 12 },
      "bind": { "kind": "cameraName" },
      "style": { "font": "sans", "weight": 750, "size": { "designPx": 20 }, "color": "rgba(20,20,22,0.92)" },
      "editable": { "visible": true }
    },
    {
      "id": "lens",
      "type": "text",
      "zone": "footer",
      "grid": { "col": 1, "colSpan": 5, "row": 7, "rowSpan": 6 },
      "bind": { "kind": "lensName" },
      "condition": { "hideWhenEmpty": true },
      "style": { "font": "sans", "weight": 650, "size": { "designPx": 13 }, "color": "rgba(60,60,66,0.62)" },
      "editable": { "visible": true }
    },
    {
      "id": "settings",
      "type": "text",
      "zone": "footer",
      "grid": { "col": 8, "colSpan": 5, "row": 1, "rowSpan": 12 },
      "bind": { "kind": "settingsLine" },
      "style": { "font": "sans", "weight": 700, "size": { "designPx": 14 }, "color": "rgba(20,20,22,0.9)", "align": "right" },
      "editable": { "visible": true }
    },
    {
      "id": "maker",
      "type": "logo",
      "zone": "footer",
      "grid": { "col": 6, "colSpan": 2, "row": 1, "rowSpan": 12 },
      "bind": { "kind": "makerLogoKey" },
      "style": { "logoStyle": "color", "opacity": 0.55, "maxHeight": { "designPx": 22 } },
      "editable": { "visible": true, "logoStyle": true, "monoColor": true }
    }
  ]
}
```

### 3.2 Binding（数据绑定）建议做成“白名单能力”
为了让模板可配置但不失控，binding 建议只允许引用我们提供的函数/字段：
- `cameraName(exif)`
- `lensName(exif)`
- `settingsLine(exif)`（复用 `formatSettingsLine` 或现有 `buildSettingsParts`）
- `dateTime(exif)`
- `makeKey(exif)`（复用 `inferMakerLogoKey`）
- `palette`（如果启用抽色板）
- `makerLogoKey(exif)`（厂商 Logo 的 key；Level 1 不允许用户手动指定 key）

### 3.3 Variants（条件变体）
> 你已确认：这一版**暂不做**（先把基础引擎 + Level 1 编辑跑通）。本节保留为后续扩展点。

现实里模板往往需要“横图/竖图不同布局”，建议从一开始就支持变体：
- `when: { aspectRatio: 'portrait' | 'landscape', minWidth?, maxWidth? }`
- `patch: { layout?:..., elements?:... }`（对某些属性做覆盖）

> 这能避免“同一模板拆两份”的维护灾难。

### 3.4 Overrides（用户编辑结果）
用户编辑应该是**覆盖默认模板**，而不是修改模板本体：
- 存储：`localStorage`（与“纯本地”一致）
- 维度：
  - per-template（某模板的默认风格）
  - 可选 per-photo（某张照片临时调整）
- 覆盖内容：
  - `visible: boolean`
  - `textOverride: string`
  - `logoKeyOverride: string`
  - `placementOverride`（高级：改网格坐标/offset）
  - `styleOverride`（高级：字号/颜色）

---

## 4. 渲染引擎（Template Engine）落地方案

### 4.1 渲染分阶段（对应现有 `renderWatermark`）
建议把现在的 `renderWatermark` 继续作为入口，但内部变成：
1. **准备 RenderContext**
   - 输出尺寸（含 orientation swap）
   - `exif`（已读取）
   - `makerLogo`（由 key 推断并加载）
   - `palette`（按需）
2. **layout 解析**
   - 计算 `canvasRect/photoRect/zones`
   - 构建各 zone 的 grid context
3. **渲染 Photo Layer**
   - 背景（纯色/渐变/卡片阴影）
   - 绘制照片到 `photoRect`
4. **渲染 Overlay Layer**
   - 按元素列表顺序绘制（或按 zIndex）
   - 对 text 应用 `fitText`、对 group 应用 stack 布局

### 4.2 “多元素 + 网格”引擎最小可用集合（MVP）
为了能尽快把现有模板迁移到新框架，建议先支持以下 element：
- `text`：单行文本（先不做自动换行，保持 `fitText`）
- `logo`：厂商 logo（内置素材）
- `rect`：底栏背景/卡片背景（含圆角）
- `divider`：直线/横线
- `swatches`：色卡
- `stack`：垂直/水平堆叠（用来组合相机+日期等）

### 4.3 Logo 两套风格（彩色/单色）的落地方式
你要求“彩色/单色”两套风格，但我们目前的内置素材主要是“原始彩色 SVG”。为了避免维护两套素材文件，建议引擎支持：

- `logoStyle: "color" | "mono"`（模板默认值 + Level 1 可切换）
- `monoColor: "auto" | "#000000" | "#ffffff" | "#RRGGBB"`（建议先支持 `auto/#000/#fff`）

**实现建议（canvas 内 tint）**
1. 正常加载彩色 SVG（同源资源，不会 taint）
2. 单色模式时：把 logo 先画到一个 offscreen canvas（尺寸=最终绘制尺寸）
3. `globalCompositeOperation = "source-in"`，再 `fillRect` 用目标颜色覆盖 → 得到单色 logo
4. 缓存结果（key + color + size）避免每次重算

这样：
- 模板 JSON 不需要携带两套素材路径
- 未来如果我们补充“官方单色素材”，也可以在 loader 层覆盖掉 tint 方案

### 4.3 迁移策略（保持可回滚）
建议“新旧模板并存一段时间”：
- 新增 `TemplateDefinition` 与 `renderTemplateDefinition(...)`
- 旧的 `WatermarkTemplate.render(...)` 仍可用（保障稳定）
- 逐个模板迁移到新引擎，迁移完成后再删旧实现

---

## 5. UI：元素编辑器（让“可编辑元素”真的可用）

### 5.1 最小可用编辑（先做“内容/开关”，再做“位置/样式”）
MVP 编辑能力建议按难度分层：

**Level 1（低难度，高价值）**
- 元素开关：显示/隐藏（例如不想显示镜头）
- 文本覆盖：例如把 `SHOT ON ...` 改成 `Taken with ...`
- Logo：显示/隐藏、风格（彩色/单色）、单色颜色（可选 #RRGGBB）

**Level 2（中等难度）**
- 位置覆盖：基于网格选择 col/row（下拉/步进器）
- 对齐：left/center/right + top/middle/bottom

**Level 3（高难度）**
- 可视化拖拽（WYSIWYG），并能“吸附网格”
- 多行排版、自动换行、文字避让、碰撞检测

### 5.2 状态存储与导入导出
- 纯本地：存 `localStorage`
- 支持导出 JSON（分享模板风格）
- 支持导入 JSON（快速复用）

---

## 6. 可执行的实施计划（分阶段）

### Phase A：设计与对齐（本文件）
- [ ] 确认要支持的元素清单（文本/Logo/色卡/边框/阴影等）
- [ ] 确认网格系统（12列？还是更自由的 rows/cols？）
- [ ] 确认编辑器范围（先 Level 1 还是直接做 Level 2）

### Phase B：引擎骨架（不改 UI 的前提下先跑通）
1. 新建 `render/engine/`（或 `render/v2/`）并定义类型
2. 实现 `layout`（canvas/photo/zones/grid）
3. 实现 `elements`（text/logo/rect/divider/swatches/stack）
4. 实现 JSON loader + 轻量校验（读内置模板 JSON）
5. 让引擎可在 `renderWatermark` 中被调用（仍保留旧模板路径）

验收：
- 新引擎能渲染出 1 个模板（建议从 `classic_footer` 开始）

### Phase C：迁移现有模板（每迁移一个就对比效果）
建议迁移顺序（由简单到复杂）：
1. `classic_footer`（footer zone + 三段布局）
2. `picseal_banner`（两列 + 分割线 + 右侧品牌）
3. `ezmark_card`（卡片背景 + 色卡 + 右上品牌 + 文本避让）

验收：
- 迁移后的模板视觉接近现状（允许细节微调），并且模板定义主要是“数据”

### Phase D：编辑器 Level 1（内容/开关/Logo）
1. 读取模板的 elements 列表生成 UI
2. 增加 overrides（localStorage）
3. 渲染时应用 overrides

验收：
- 用户能关掉镜头/日期/参数任一行
- 用户能改 `SHOT ON ...` 的固定前缀或整行文案
- 用户能切换 Logo 显示策略（auto/fixed/off）+ 风格（彩色/单色）

### Phase E：编辑器 Level 2（网格位置）
1. 对 element 提供 `grid.col/colSpan/row/rowSpan` 的编辑控件
2. 支持“对齐/偏移/最大宽度”编辑
3. 可加“重置为默认”

验收：
- 用户能把 Logo 从右侧挪到中间/左侧（不需要改代码）

---

## 7. 难度与风险评估（诚实版）

### 7.1 难度分布
- **渲染引擎（模板数据化 + 元素系统）**：中等难度（主要在 layout/token/文本测量）
- **网格定位（Grid）**：中等难度（一次性建好后复用性强）
- **编辑器 Level 1（开关/内容/Logo）**：低~中等难度
- **编辑器 Level 2（位置/样式）**：中等难度（需要良好类型与状态管理）
- **可视化拖拽（Level 3）**：高难度（交互复杂、细节多、容易出 bug）

### 7.2 主要技术风险
1. **字体与测量**：Canvas 文本测量不等于排版，跨平台字体差异会导致“看起来没对齐”。
2. **缩放策略**：现有模板大量使用 `scale = clamp(...)` 手算，数据化后需要 token 体系，否则模板会很难写。
3. **碰撞与避让**：元素可编辑后可能互相遮挡；要么限制能力（MVP），要么引入碰撞检测（复杂）。
4. **变体爆炸**：没有 variants 会迫使模板复制；有 variants 则需要设计好 “when/patch” 机制。

### 7.3 建议的落地节奏
先做“**模板数据化 + 元素可开关/改内容**”，再做“**网格可编辑**”，最后才考虑“拖拽”。

---

## 8. 需要你确认的问题（我会根据你的答案细化实现细节）

你已确认：
1. 模板：JSON 文件
2. 网格：12 列栅格（建议默认 rows=12）
3. 编辑器：先 Level 1
4. Logo：彩色/单色两套风格
5. Variants：暂不做
6. Level 1 Logo key：仅 `auto/off`（不做 fixed 下拉）
7. Level 1 单色 Logo：允许用户自选颜色
8. Level 1 文本覆盖：仅 `slogan/固定文案`

（如无新增需求，这些信息已足够开始 Phase B 实现引擎骨架。）
